import sys
import os
import pandas as pd
import logging
import azure.cognitiveservices.speech as speechsdk
from pathlib import Path
# Remove pydub imports if only used for cropping/concatenation
# from pydub import AudioSegment
# from pydub.utils import make_chunks
from Preprocessing.merge_wav import merge_wav_from_folder # Import the merge function

def main(dir_name, api_key, BDD_ssml_path, Out_dir, Pause_time_end_const, Pause_break_const, region='eastus'): # Renamed BDD4_dir to BDD_ssml_path
    """Effectue la synthèse vocale pour chaque chaîne SSML de segment fournie dans un DataFrame."""
    logger = logging.getLogger(__name__)
    
    results_dir = Path(Out_dir) / 'results' / dir_name
    temp_audio_dir = results_dir / "Temp" # Directory for individual segment wavs
    final_output_wav = results_dir / "OUT.wav"

    # Ensure temp dir exists (should be created by pipeline, but double-check)
    temp_audio_dir.mkdir(parents=True, exist_ok=True)

    # Delete previous temp files and final output
    for temp_file in temp_audio_dir.glob("*.wav"):
        try:
            temp_file.unlink()
        except OSError as e:
            logger.error(f"Error removing temp file {temp_file}: {e}")
    try:
        if final_output_wav.exists():
            final_output_wav.unlink()
    except OSError as e:
        logger.error(f"Error removing previous OUT.wav {final_output_wav}: {e}")

    # Read the CORRECT csv file generated by Get_Wav.py
    try:
        # Use the path passed from the pipeline
        df = pd.read_csv(BDD_ssml_path)
        # Ensure 'segment' column is suitable for sorting filenames later
        df['segment'] = pd.to_numeric(df['segment'], errors='coerce').fillna(-1).astype(int)
        df = df[df['segment'] != -1].sort_values('segment') # Ensure order
    except FileNotFoundError:
        logger.error(f"Input SSML file not found: {BDD_ssml_path}")
        return
    except Exception as e:
        logger.error(f"Error reading SSML file {BDD_ssml_path}: {e}")
        return

    speech_config = speechsdk.SpeechConfig(subscription=api_key, region=region)
    # Assuming voice is defined in the SSML now, but set a default if needed
    # speech_config.speech_synthesis_voice_name = "en-US-AndrewNeural"

    success_count = 0
    fail_count = 0
    # Parcourir chaque segment (chaque ligne du BDD_ssml.csv)
    for index, row in df.iterrows():
        segment_num = row['segment']
        ssml_string = row['ssml']
        
        # Define output path for this segment's audio
        segment_outpath = temp_audio_dir / f"segment_{segment_num}.wav"
        audio_config = speechsdk.AudioConfig(filename=str(segment_outpath))
        speech_synthesizer = speechsdk.SpeechSynthesizer(speech_config=speech_config, audio_config=audio_config)

        logger.info(f"Synthesizing segment {segment_num} to {segment_outpath}")
        # logger.debug(f"SSML: {ssml_string}") # Log full SSML only if needed

        try:
            result = speech_synthesizer.speak_ssml_async(ssml_string).get()

            # Check the result
            if result.reason == speechsdk.ResultReason.SynthesizingAudioCompleted:
                logger.info(f"Segment {segment_num} synthesized successfully (Duration: {result.audio_duration}).")
                success_count += 1
            elif result.reason == speechsdk.ResultReason.Canceled:
                cancellation_details = result.cancellation_details
                logger.error(f"Segment {segment_num} synthesis canceled: {cancellation_details.reason}")
                if cancellation_details.reason == speechsdk.CancellationReason.Error:
                    logger.error(f"Error details: {cancellation_details.error_details}")
                    logger.error(f"Problematic SSML: {ssml_string}") # Log the SSML that failed
                fail_count += 1
            else:
                 logger.warning(f"Segment {segment_num} synthesis result reason: {result.reason}")
                 fail_count += 1

        except Exception as e:
            logger.error(f"Exception during synthesis for segment {segment_num}: {e}", exc_info=True)
            logger.error(f"Problematic SSML: {ssml_string}") # Log the SSML that failed
            fail_count += 1
        finally:
            # Clean up synthesizer and config objects
            del speech_synthesizer
            del audio_config

    logger.info(f"Synthesis attempt complete. Success: {success_count}, Failed: {fail_count}")

    # --- Merging Step ---
    if success_count > 0:
        logger.info(f"Merging {success_count} synthesized segments into {final_output_wav}")
        try:
            # Use the imported merge function
            # It expects folder path and output file path
            merge_wav_from_folder(str(temp_audio_dir), str(final_output_wav))
            logger.info(f"Final audio file created: {final_output_wav}")
        except Exception as e:
            logger.error(f"Error merging temporary audio files: {e}", exc_info=True)
    else:
        logger.warning("No segments were successfully synthesized. Final audio file not created.")

    # Optional: Clean up temp files after successful merge
    # if final_output_wav.exists() and success_count > 0:
    #    logger.info("Cleaning up temporary segment files.")
    #    for temp_file in temp_audio_dir.glob("*.wav"):
    #        try:
    #            temp_file.unlink()
    #        except OSError as e:
    #            logger.error(f"Error removing temp file {temp_file}: {e}")


if __name__ == "__main__":
    if len(sys.argv) != 7:
        print(
            "Usage: TTS_df.py",
            "<dir_name>",
            "<api_key>",
            "<BDD_ssml_path>", # Changed name
            "<Out_dir>",
            "<Pause_time_end_const>", # These might be obsolete now
            "<Pause_break_const>"     # These might be obsolete now
        )
        sys.exit(1)

    dir_name = sys.argv[1]
    api_key = sys.argv[2]
    BDD_ssml_path = sys.argv[3] # Changed name
    Out_dir = sys.argv[4]
    # These pause constants are likely no longer needed as cropping is removed
    Pause_time_end_const = float(sys.argv[5])
    Pause_break_const = float(sys.argv[6])

    # Setup basic logging if running standalone for testing
    # logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')

    main(dir_name, api_key, BDD_ssml_path, Out_dir, Pause_time_end_const, Pause_break_const)